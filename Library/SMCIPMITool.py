import subprocess
import os
import re
from Library.Execeptions import SMCError, SUMError
from Library.Common_Func import Check_ipaddr, Check_PWD
from time import sleep

class SMCIPMITool():
    def __init__(self, ip, uni_pwd) -> None:
        self.Path = 'C:\\Users\\Stephenhuang\\SMCIPMITool_2.28.0_build.240703_bundleJRE_Windows'
        self.ip = ip
        Auth = Check_PWD(ip, uni_pwd)
        self.accout = f' {Auth[0]} '
        self.pwd = f'{Auth[1]} '
        self.uni_pwd = uni_pwd
        # print(Auth)
    
    def Execute(self, cmd:str):
        if os.path.exists(self.Path):
            execute = subprocess.run('SMCIPMITool.exe '+ self.ip + self.accout + self.pwd + cmd, shell=True, capture_output=True, universal_newlines=True, cwd=self.Path, timeout=120)
            if execute.returncode == 0:
                return execute.stdout
            else:
                return f'{execute.stdout}\nError: {execute.stderr}\nReturn code: {execute.returncode}'
        else:
            print(SMCError(f'{self.Path} is not found'))
            exit()

    def raw(self, cmd:str):
        return self.Execute('ipmi raw '+cmd)
    
    def raw_06_01(self):
        print(self.raw('06 01'))
    
    def raw_30_74_01(self):
        """
        - Check if unique password has been activated
        - 01 activated
        """
        print(f"Execute ipmi raw 30 74 01\n{self.raw('30 74 01')}")
    
    def raw_30_68_09(self, cmd:str):
        return self.raw('30 68 09 '+cmd)

    def raw_30_68_0A(self, cmd:str):
        return self.raw('30 68 0A '+cmd)

    def raw_30_41(self):
        print(f"Execute ipmi raw 30 41\n{self.raw('30 41')}")


    def raw_30_48_1(self):
        print(f"Execute ipmi raw 30 48 1\n{self.raw('30 48 1')}")

    def get_sensors(self):
        print(f"Execute ipmi sensor on {self.ip}\n{self.Execute('ipmi sensor --full')}")

    def Check_sensors_status(self):
        """`0E` or `1E`: No sensor, `0F` or `1F`: has sensor"""
        output = self.raw('30 68 F9')
        print(output)
        return output

    def is_sensor_up(self):
        check = self.Check_sensors_status()
        return True if '0F' in check or '1F' in check else False

    def get_lani_id_list(self):
        lani_output = self.Execute('ipmi oem lani')
        # print(lani_output)
        regex = r"\d"
        result = re.findall(regex, lani_output)
        return result

    def Raw_Factory_Default(self):
        print(f'Server IP: {self.ip}')
        timeout = 130 if self.ip.split('.')[0] == '10' else 150
        self.raw_30_41()
        sleep(timeout)
        self.pwd = self.uni_pwd
        self.raw_30_48_1()
        sleep(timeout)
        print('Completed') if Check_ipaddr(self.ip) else print(f"{self.ip} is still offline!")

    def smc_command(self, cmd:str): 
        output = self.Execute(cmd)
        print(output)

    def smc_commands(self, cmds:str):
        """- Input: cmd A, cmd B, cmd C"""
        cmds = cmds.strip()
        cmds_list = []

        cmds_list = cmds.split(',')
        for i in range(len(cmds_list)):
            cmds_list[i] = cmds_list[i].strip()
        for cmd in cmds_list:
            print(f"Execute {cmd}")
            output = self.Execute(cmd)
            print(output)



class SMCIPMITool_Internal():
    def __init__(self, ip, uni_pwd) -> None:
        self.Path = 'D:\\SMCIPMITool_2.27.3_(internal)_build.230727_bundleJRE_Windows'
        self.ip = ip
        Auth = Check_PWD(ip, uni_pwd)
        self.accout = f' {Auth[0]} '
        self.pwd = f'{Auth[1]} '

    def Execute(self, cmd:str):
        if os.path.exists(self.Path):
            execute = subprocess.run('SMCIPMITool.exe '+ self.ip + self.accout + self.pwd + cmd, shell=True, capture_output=True, universal_newlines=True, cwd=self.Path, timeout=120)
            # print(self.ip, self.pwd, cmd)
            if execute.returncode == 0:
                return execute.stdout
            else:
                return f'{execute.stdout}\nError: {execute.stderr}\nReturn code: {execute.returncode}'
        else:
            print(SMCError(f'{self.Path} is not found'))
            exit()    

    def Check_BS(self):
        print(f'Server IP: {self.ip}')
        fru1 = self.Execute('ipmi fru1')
        if 'Error' in fru1: print(fru1)
        for output in fru1.splitlines():
            # if any(fru in output for fru in ['BPN','BS','BP','BV']):
            if 'BS' in output:
                print(output)
                SN_number = output.split('=')[-1]
                if len(SN_number) < 10:
                    text = input('Input BS: ')
                    bs1 = self.Execute('ipmi fru1w BS '+ text + ' Supermicro82265990')
                    bs = self.Execute('ipmi fruw BS ' + text)
                    print(f'Fru1 BS modify success\nFru1: {bs1}') if 'Error' not in bs1 else print(f'Fru1 BS modify failed')
                    print(f'Fru BS modify success\nFru: {bs}') if 'Error' not in bs else print(f'Fru BS modify failed')
                    # bs1_num = [num.split('=') for num in bs1.splitlines() if 'BS' in num] #[['Board Serial Number (BS)       ', ' WM241S005606']]
                    # bs_num = [num.split('=') for num in bs.splitlines() if 'BS' in num]
                else: print('BS is match')

            if 'BM' in output:
                if 'Supermicro' != output.split('=')[-1].lstrip():
                    print(f"BM doesn't match\nStart override")
                    bm1 = self.Execute('ipmi fru1w BM Supermicro Supermicro82265990')
                    bm = self.Execute('ipmi fruw BM Supermicro')
                    print(f'Fru1 BM modify success') if 'Error' not in bm1 else print(f'Fru1 BM modify failed')
                    print(f'Fru BM modify success') if 'Error' not in bm else print(f'Fru BM modify failed')
                else: print(f"{output}\nBM is match")



class SUMTool():
    def __init__(self, ip, uni_pwd) -> None:
        self.Path = 'C:\\Users\\Stephenhuang\\sum_2.14.0-p1_Win_x86_64'
        self.ip = ip
        Auth = Check_PWD(ip, uni_pwd)
        self.account = Auth[0]
        self.pwd = Auth[1]
        # print(Auth)
    
    def Execute(self, cmd:str):
        if os.path.exists(self.Path):
            execute = subprocess.run('sum.exe -i '+self.ip+' -u '+self.account+' -p '+self.pwd+' -c '+cmd, shell=True, capture_output=True, universal_newlines=True, cwd=self.Path)
            if execute.returncode == 0 and execute.stdout != '':
                return execute.stdout
            elif execute.returncode == 0 and execute.stdout == '':
                return execute.stderr
            else:
                return f'{execute.stdout}\nError: {execute.stderr}\nReturn code: {execute.returncode}'
        else:
            print(SUMError(f'{self.Path} is not found'))

    def get_bmc_info(self):
        print(self.Execute('GetBmcInfo --showall'))

        # Error:
        # Return code: 146 可以用來判斷
    
    def print_bios_info(self):
        print(self.Execute('GetBiosInfo --showall'))
    
    def get_bios_info(self):
        return self.Execute('GetBiosInfo --showall')
    
    def get_cpld_info(self):
        print(self.Execute('GetCpldInfo'))
    
    def get_psu_info(self):
        print(self.Execute('GetPSUInfo'))

    def SUT_info(self):
        '''return 3 variables, `bmc`, `bios`, `cpld` '''
        bmc = self.get_bmc_info()
        bios = self.get_bios_info()
        cpld = self.get_cpld_info()
        # psu = self.get_psu_info()
        return bmc, bios, cpld

# SMC_tool = SMCIPMITool()